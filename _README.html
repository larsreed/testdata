<!doctype html>
<html lang="en">
<head>
  <title>Using ReMarkdown</title>
  <link rel="stylesheet" href="remarkdown.css">
</head>
<body class="rmd-on">
           <h1>Testdatagenerator</h1>

<p>This project contains a simple set of tools to help generate test data.  It is primarily a way to train myself in Scala (by porting and enhancing some very old AWK scripts :), but can hopefully be useful to someone...</p>

<h2>Overview</h2>
<p>The basic component is the <b><code>Generator[T]</code></b> trait, which is able to provide a (possibly filtered) list of instances of a given type, as well as the same list converted to strings.</p>

<p>On top of this is a set of generators based on the <b><code>ExtendedGenerator[T]</code></b> interface, containing methods to set up lists of basic data like strings and numbers.</p>

<p>Furthermore, there are some utility classes like <tt>FieldConcatenator</tt> and <tt>WeightedGenerator</tt> to assist in creating aggregate or more complex data.</p>

<p>And finally, there are a set of classes to assist in creating complete data records, like <tt>ToSql</tt> for generating SQL inserts, and <tt>ToCsv</tt> to create simple flat file records.</p>

<h3>Sample usage</h3>
<p>Here is an introductory example to give you a sense of what it's all about:<br>
</p>
<pre>
package no.mesan.testdatagen.generators.sample

import no.mesan.testdatagen.aggreg.{FieldConcatenator, SomeNulls, WeightedGenerator}
import no.mesan.testdatagen.generators.{Dates, Doubles, Fixed, FromList, Ints}
import no.mesan.testdatagen.generators.misc.Names
import no.mesan.testdatagen.recordgen.{SkipNull, ToXmlElements}

object SimpleSample extends App {
  ToXmlElements("order", "orderLine", SkipNull)
    .add("id", Ints() from(1) sequential)
    .add("productName", WeightedGenerator()
                         .add(3, Names(1))
                         .add(2, Names(2)))
    .add("qty", SomeNulls(33,
                 FieldConcatenator()
                   .add(Doubles() from(1) to(300) format("%5.2f"))
                   .add(Fixed(" "))
                   .add(FromList("l", "kg", "", "m"))))
    .add("orderDate", Dates() from(y=2012, m=9) to(y=2013, m=1) format("yyyy-MM-dd"))
    .toFile("orders.xml")
    .getStrings(1000)
}
</pre>

<p>This produces an XML-file, <tt>order.xml</tt>, with the following content:</p>
<pre>&lt;order&gt;
   &lt;orderLine&gt;
      &lt;id&gt;1&lt;/id&gt;
      &lt;productName&gt;Shrpfljookmlvkpe&lt;/productName&gt;
      &lt;orderDate&gt;2012-11-24&lt;/orderDate&gt;
   &lt;/orderLine&gt;
   &lt;orderLine&gt;
      &lt;id&gt;2&lt;/id&gt;
      &lt;productName&gt;Ysmlyjyvygsrtbr Dnbldegkieivvdrut&lt;/productName&gt;
      &lt;qty&gt;113,99 kg&lt;/qty&gt;
      &lt;orderDate&gt;2012-10-20&lt;/orderDate&gt;
   &lt;/orderLine&gt;
   &lt;orderLine&gt;
      &lt;id&gt;3&lt;/id&gt;
      &lt;productName&gt;Iphlifhmopaka&lt;/productName&gt;
      &lt;qty&gt;87,77 kg&lt;/qty&gt;
      &lt;orderDate&gt;2012-11-04&lt;/orderDate&gt;
   &lt;/orderLine&gt;
   &lt;orderLine&gt;
      &lt;id&gt;4&lt;/id&gt;
      &lt;productName&gt;Afoubrksoomnhehtt Leoiom&lt;/productName&gt;
      &lt;qty&gt;283,82 l&lt;/qty&gt;
      &lt;orderDate&gt;2012-09-16&lt;/orderDate&gt;
   &lt;/orderLine&gt;
&lt;/order&gt;
</pre>
</div></div>

<p>For a more thorough example, scroll down...</p>

<h2>Core definitions</h2>

<h3>Generator</h3>
<p>The basic generator trait looks like this (details omitted):</p>

<pre>
trait Generator[T] {
  /** Get the next n entries. */
  def get(n: Int): List[T]

  /** Get n entries converted to strings and formatted. */
  def getStrings(n:Int): List[String]

  /** Set a formatting function. */
  def format(f: T=&gt;String): this.type

  /** Add a filter function. */
  def filterWith(f: T=>Boolean): this.type
}</pre>

<p>The elements here are:</p>
<ol>
	<li><b><code>get(n)</code></b>: The main function, providing  a list of <em>n</em> data elements.</li>
	<li><b><code>getStrings(n)</code></b>: Returns the same list as the previous, but mapped via the formatter function (see below) and thus converted to string format.</li>
	<li><b><code>filter(f)</code></b>: Adds a function that takes an instance of the generator's type and returns <tt>true</tt> if the instance should be included in the list.  Should be applied before constructing the final list (to ensure that <code>get(n)</code> actually contains n elements). The function may be called several times to add multiple filters to apply &ndash; each filter must accept the instance to include it in the final list.</li>
	<li><b><code>formatWith(f)</code></b>: Adds a formatting function that takes an instance of the given type <tt>T</tt> and formats it as a string.</li>
</ol>


<h4>GeneratorImpl</h4>
<p>is a simple trait containing a sufficient implementation of most of the generator methods (except <tt>get</tt>).  Implementing classes get the following members:</p>
<ul>
	<li><tt>protected var filterFuns</tt> and <tt>protected def filterAll(elem:T)</tt> &ndash; the list of defined filters and a function to check them all at once.<br>
A default filter function that accepts any input is included.</li>
	<li><tt>protected var formatter</tt> which is the defined formatting function, defaulting to a simple <tt>toString</tt>.</li>
	<li>An implementation of <tt>getStrings</tt> that calls <tt>get</tt> and formats each element with the formatter.</li>
</ul>


<h3>ExtendedGenerator</h3>
<p>The ExtendedGenerator trait extends the <tt>Generator</tt> trait with
methods to control how data is generated.</p>
<pre>trait ExtendedGenerator[T] extends Generator[T] {
  /** Set a formatting string. */
  def format(f: String): this.type

  /** Lower bound.  */
  def from(min: T): this.type

  /** Upper bound. */
  def to(max: T): this.type

  /** Generate sequential, not random. */
  def sequential: this.type

  /** Generate unique, random values. */
  def unique: this.type

  /** Generate reversed sequential values. */
  def reversed: this.type
}
</pre>

<p>The general methods are:</p>
<ol>
	<li><b><code>format(s)</code></b>: A simpler way to define a formatting function, by providing a simple format string for <tt>java.lang.String.format</tt>.</li>
	<li><b><code>from(T) / to(T)</code></b>: defines a lower/upper bound for generated values (takes a value of the output type, subclasses may provide variants)</li>
	<li><b><code>sequential</code></b>: Signals that sequential values are to be generated (subclasses may define a step size) &ndash; by default, random values are generated.<br>
Generation starts at the lower bound, generating towards the upper.  If the upper bound is reached without providing the wanted <em>n</em> occurrences, it wraps around from the start.  E.g.: when getting 6 numbers from <tt>Ints() from(0) to(1) sequential</tt> you get 0,1,0,1,0,1.</li>
	<li><b><code>reversed</code></b>: Calling this implies a call to <tt>sequential</tt>; additionally, generation starts at the upper bound, stepping towards the lower.</li>
	<li><b><code>unique</code></b>: Calling this sets the generation to random, and then checks to see that each generated value is unique.</li>
</ol>


<p>All the methods return <tt>this.type</tt> (ending up in the type of the class implementing the trait), to allow <em>builders</em> like <tt>Ints() from(1) to(10) reversed</tt>.</p>

<p>As the method definitions imply, generators will by default pick <em>random</em> sequences from their value space (the range of the underlying data type(s), possibly limited by from/to-arguments).  When <tt>unique</tt> is added, it will check to see that the same value is never drawn twice.  For generators with a limited value space, you should be careful with this setting &ndash; <tt>FromList(List(1,2)).unique.get(3)</tt> will probably crash or run forever...<br>
The methods <tt>sequential</tt> and <tt>reversed</tt> (and for some subclasses, a <tt>step</tt> method) change this behaviour &ndash; instead a series of increasing (or decreasing) values will be produced.<br>
Sometimes you will find it necessary to have two generators A and B draw from the same value space.  In that case, you could use a generator to fill a list, and then use a <tt>FromList</tt> to produce the final values.</p>

<h4>SingleGenerator</h4>
<p><tt>SingleGenerator</tt> is an abstract base class extending <code>ExtendedGenerator[T]</code> backed by <code>GeneratorImpl[T]</code>.  All methods except <code>get(n)</code> are defined.<br>
Subclasses get the following <tt>protected</tt> members:</p>
<ul>
	<li><code>var lower: Option[T]</code></li>
	<li><code>var upper: Option[T]</code></li>
	<li><tt>var isSequential</tt></li>
	<li><tt>final def isRandom= !isSequential</tt></li>
	<li><tt>var isUnique</tt></li>
	<li><tt>var isReversed</tt></li>
</ul>


<h4>ExtendedDelegate</h4>
<p>The final basic building block is the <code>trait ExtendedDelegate[G, T]</code>.<br>
This trait</p>
<ul>
	<li>can only be used on a type implementing <code>Generator[T]</code></li>
	<li>requires the implementing type to have a <code>var generator:Generator[G]</code> containing the actual generator</li>
	<li>allows you to override
	<ul>
		<li>only the methods of <tt>ExtendedGenerator</tt> you need to change</li>
		<li>the definition of <tt>def conv2gen(f: T): G</tt> and / or <code>conv2result(f: G): T</code> to convert between the types of the generator and the implementing class (by default both are implemented with <tt>asInstanceOf</tt></li>
	</ul>
	</li>
</ul>


<h2>Basic generators</h2>

<h3>Booleans</h3>
<p>This class has the rather simple job of generating Booleans...  It uses <tt>FromList</tt> under the hood.</p>
<ul>
	<li><tt>from</tt> and <tt>to</tt> are not supported</li>
	<li>an additional method <tt>format(falseString, trueString)</tt> is available for the conversion in <tt>getStrings</tt></li>
</ul>


<p>Apply methods:</p>
<ol>
	<li><tt>Booleans()</tt></li>
	<li><tt>Booleans(trueString, falseString)</tt></li>
</ol>


<h3>Ints</h3>
<p>returns ints from the entire range.  The only special method is</p>
<ul>
	<li><tt>step(Int)</tt> to define step size for sequences</li>
</ul>


<p>Apply methods (defaults for all parameters):</p>
<ul>
	<li><tt>Ints(from:Int=Int.MinValue+1, to:Int=Int.MaxValue-1, step:Int=1)</tt></li>
</ul>


<h3>Longs</h3>
<p>returns longs from the entire range.  The only special method is</p>
<ul>
	<li><tt>step(Long)</tt> to define step size for sequences</li>
</ul>


<p>Apply methods (defaults for all parameters):</p>
<ul>
	<li><tt>Longs(from:Long=0, to:Long=Long.MaxValue-1, step:Int=1)</tt> (note default 0 for start)</li>
</ul>


<h3>Chars</h3>
<p>uses <tt>ExtendedDelegate</tt> and a 1-character <tt>Strings</tt>-generator to do its work.  It adds</p>
<ul>
	<li>the <code>chars(Seq[Char])</code> method &ndash; also supported by <tt>Strings</tt> &ndash; to add a range of available characters.  Accepts a string (<tt>chars("aeiouy")</tt>), an interval (<tt>chars('a' to 'z')</tt>) etc.</li>
</ul>


<p>Apply methods:</p>
<ol>
	<li><tt>Chars()</tt></li>
	<li><tt>Chars(seq)</tt></li>
</ol>


<h3>Doubles</h3>
<p>returns doubles from the entire range.  The only special method is</p>
<ul>
	<li><tt>step(Double)</tt> to define step size for sequences</li>
</ul>


<p>Apply methods:</p>
<ol>
	<li><tt>Double()</tt></li>
</ol>


<h3>Dates</h3>
<p>A simple enough data type, this is still one of the more complex generators.  It uses JodaTime for date/time representation, although conversions for <tt>java.util.Date</tt> are available.  There are a lot of special methods:</p>
<ul>
	<li><tt>timeOnly</tt>: generates different times with date part omitted</li>
	<li><tt>dateAndTime</tt>: include both date and time in the output (default is just date)</li>
	<li><tt>setStdTime(h: Int, min:Int, s:Int, ms:Int)</tt>: set the standard time parts used when generating (default 0,0,0,0)</li>
	<li><tt>setStdDate(y: Int, m:Int, d:Int)</tt>: set the standard date parts used when generating (default today's date)</li>
	<li><tt>from(java.util.Date)</tt> / <tt>to(java.util.Date)</tt>: limit using JDK Dates rather than Joda DateTimes.</li>
	<li><tt>from(y: Int=1753, m: Int=1, d:Int=1, hh: Int=0, mm: Int=0, ss:Int=0, ms: Int=0)</tt> / <tt>to(y: Int=9999, m: Int=12, d:Int= -31, hh: Int=23, mm: Int=59, ss:Int=59, ms: Int=999)</tt>: These are designed to be used with named arguments, like <tt>from(y=1980, m=1) to(y=1999, m=12)</tt></li>
	<li><tt>step(y: Int=0, m: Int=0, d:Int=0, hh: Int=0, mm: Int=0, ss:Int=0, ms:Int=0)</tt>: Another candidate for named arguments, this method sets the interval for sequential generation</li>
	<li><tt>format(DateTimeFormatter)</tt>: Use one of Joda's formatters</li>
	<li><tt>getJavaDates(n:Int)</tt>: same as <tt>get</tt>, but converts to <tt>java.util.Date</tt></li>
	<li><tt>Dates.dateFormatter(formatString)</tt>: returns a partial function to format dates according to a given string</li>
</ul>



<h3>Strings</h3>
<p>The Strings generator generate strings, would you believe it...</p>

<p>Special methods:</p>
<ul>
	<li><code>length(n)</code> / <tt>lengthBetween(from, to)</tt>: sets the required length (default 1) of the generated strings</li>
	<li><code>chars(Seq[Char])</code>: defines the default characters to build strings from (default printable ASCII, i.e. space to  <tt>~</tt>).<br>
Note that there are many ways to define a <code>Seq[Char]</code>, e.g.
	<ul>
		<li><tt>"aeiuoy"</tt></li>
		<li><tt>'a' to 'z'</tt></li>
		<li><code>'a' to 'z' filter {x=&gt; !"aeiouy".contains(x)}</code></li>
	</ul>
	</li>
</ul>


<p>Apply methods:</p>
<ul>
	<li><tt>Strings(length: Int=0)</tt>: default method, exact length may be given</li>
	<li><code>Strings(length: Int, chars:Seq[Char])</code>: supply length and character set</li>
</ul>



<h3>Fixed</h3>
<p>This generator may seem superfluous...  It takes a single value, and returns that same value repeatedly.  But it is meant for aggregating values, see <tt>FieldConcatenator</tt> for an example.</p>

<p>This "generator" is actually just an apply method taking a single value, it is backed by a <tt>FromList</tt>.</p>

<h3>FromFile</h3>
<p>This generator reads lines from an input file and creates a list of values, from which a delegate <tt>FromList</tt> can take its values. The values may be typed (does not currently work as expected...), even though they are read as strings.</p>

<p>Specialities:</p>
<ul>
	<li>The <tt>from</tt> and <tt>to</tt> methods are not supported.</li>
	<li><tt>allLines(all:Boolean=true)</tt>: to support large input files, the generator only reads the first <em>n</em> lines from the file when asked to produce <em>n</em> values.  To utilize the entire file, call <tt>allLines</tt> before getting input, this is meaningless for sequential output, but increases the value space for random generation.</li>
</ul>


<p>Apply method:</p>
<ul>
	<li><tt>FromFile(resourceName: String, allLines:Boolean=false, encoding: String= "ISO-8859-1")</tt>: A file name must be given, allLines is optional (see the similar method), so is the encoding to be used (defaults to ISO-8859-1).<br>
The file to be read is first searched for on the classpath, then as a regular file name.  Since reading is not done until a get-method is called, invalid file names will not be detected when <em>constructing</em> the generator.</li>
</ul>



<h3>FromList</h3>
<p>Probably the most versatile of all the generators, the FromList takes a list of "anything" as input and generates its values from that, it is typed (<code>FromList[T]</code>), so you keep the type of the input list.<br>
To name a few possible uses:</p>
<ol>
	<li>If you already have a list of the values you want to pick from, the FromList takes care of the rest...  This is what the Boolean (short list :), fixed (even shorter) and FromFile generators do.  You could just as well use it for a list of Person objects or DOM trees...</li>
	<li>As mentioned above, if you need to reuse the same values in several generators, e.g. if you need "foreign keys" from one generator to another, you could generate the needed values in a list, and use that list for the other generators.</li>
	<li>You could use it to scramble existing data.  E.g.: do a <tt>select Id, FirstName, LastName, Address, CreditCardNumber from Customer</tt> in your code, keep the field values in each their list, and the generate a number of <tt>inserts</tt> picking random values from the lists.</li>
</ol>


<p>Specialities:</p>
<ul>
	<li><tt>from</tt> and <tt>to</tt> are not supported</li>
	<li>The method <tt>fromList(list)</tt> <b>must</b> be called before you generate values (unless you use the apply method with a list argument).</li>
</ul>


<p>Apply methods:</p>
<ul>
	<li><tt>FromList()</tt> &ndash; then you <em>must</em> call <tt>fromList</tt> afterwards</li>
	<li><tt>FromList(List)</tt></li>
	<li><tt>FromList(T*)</tt> &ndash; e.g. <tt>FromList(1,2,4,8,16,32,64)</tt></li>
</ul>


<h2>Aggregates</h2>
<p>There will often be a need to handle more complex data than what the basic generators can produce. A set of generators are provided to facilitate building of aggregate constructs.</p>

<h3>TextWrapper</h3>
<p>This generator takes any other generator as input, always uses its <code>getStrings(n)</code> as input, thus acting as "text converter", and adds methods to manipulate the resulting text.</p>


<p>Special methods:</p>
<ul>
	<li><code>substring(from:Int, to:Int=-1)</code> (if <tt>to</tt> is omitted, the rest of the string is used)</li>
	<li><tt>toLower</tt> / <tt>toUpper</tt> / <tt>trim</tt> &ndash; as in <tt>java.lang.String</tt></li>
	<li><code>surroundWith(prefix:String="", suffix:String="")</code> pre/suffixes the result string with fixed strings</li>
	<li><code>transform(f: String=&gt; String)</code> &ndash; add your own string transformer function</li>
</ul>


<p>Apply methods:</p>
<ul>
	<li><tt>TextWrapper(generator)</tt></li>
</ul>


<h3>FieldConcatenator</h3>
<p>You saw the <tt>FieldConcatenator</tt> in action in the introductory example:</p>
<pre>FieldConcatenator().
  add(Doubles() from(1) to(300) format("%5.2f")).
  add(Fixed(" ")).
  add(FromList(List("l", "kg", "", "m")))
</pre>
<p>The FieldConcatenator is given a set of generators with the <tt>add</tt> method. When <tt>get</tt> is called, it calls <tt>getString</tt> on each of its generators, and concatenates the output from each generator (in the same order as the <tt>add</tt> calls), and returns the list of concatenated strings (in the above example strings like "12.04 kg").</p>

<h3>SomeNulls</h3>
<p>This generator takes another generator and a percentage as input.  Both the <tt>get</tt> and the <tt>getStrings</tt> method calls the original generator to retrieve its values, and then replaces approximately N % of the occurrences (decided by a random generator) with <tt>null</tt>.  N==0 means no nulls, N==100 means only nulls, N==50 50% nulls etc.</p>

<p>Methods:</p>
<ul>
	<li><tt>nullFactor(percent:Int)</tt> as described above</li>
</ul>


<p>Apply methods:</p>
<ul>
	<li><tt>SomeNulls(percent, generator)</tt>: supply both the factor and the generator</li>
</ul>


<h3>WeightedGenerator</h3>
<p>This generator takes one or more generators as input, and selects randomly between them for each value to generate. It is typed as a <code>Generator[Any]</code>, since it can wrap a free mix of generator types.<br>
Each generator is given a weight &ndash; the probability for each one is its own weight relative to the sum of all weights.</p>

<ul>
	<li><code>add(weight: Int, gen: Generator[_])</code></li>
	<li>Apply: noargs</li>
</ul>



<h2>Specialized generators</h2>

<h3>Names</h3>
<p>Creates "name-like" strings &ndash; words containing A-Zs with random length between 3 and 20 with an uppercase first letter.  You can see some sample output in the product names in the introductory example.  This is only a wrapper object around a <tt>Strings</tt> generator, its only parameter is an int telling how many space-separated words to create in each string.</p>

<h3>CarMakes</h3>
<p>This generator selects from a list of about a 100 manufacturers of cars, motor cycles etc, like "Porsche" and "Toyota".<br>
No class, just an apply method without parameters returning a <tt>FromList</tt>.</p>

<h3>Urls</h3>
<p>Builds fake URLs using a http/https prefix, "://", sometimes "www.", a lowercase string (a-z) of length 4-10, and a suffix of .com/no/org/net/co.uk/gov.<br>
No class, just an apply method without parameters.</p>

<h3>MailAddresses</h3>
<p>Builds email addresses using this pattern:</p>
<ol>
	<li>A name of 3-8 letters (a-z)</li>
	<li>Sometimes expanded with "." and another name (4-9 letters)</li>
	<li>"@"</li>
	<li>A name of 4-9 characters</li>
	<li>"."</li>
	<li>com/no/org/net/co.uk/gov</li>
</ol>


<h3>Guids</h3>
<p>This generator is a (perhaps too) simple generator for GUIDs, basically 128-bits integers, NOT following the rules laid out in <a href="http://www.ietf.org/rfc/rfc4122.txt">http://www.ietf.org/rfc/rfc4122.txt</a> etc.<br>
There are 3 get-methods (and only a default apply method):</p>
<ol>
	<li><code>get(n)</code>: returns a list of <code>Seq[Int]</code>, with 4 positive longs; with 32, 16, 16 and 64 bits respectively (negative numbers are not generated)</li>
	<li><code>getStrings(n)</code>: the numbers are formatted as hex strings in the format "hhhhhhhh-hhhh-hhhh-hhhhhhhhhhhhhhhh" (unless you call <tt>formatWith</tt> with another formatter)
	<ul>
		<li>If you need something like the standard Windows references, you can use a <tt>TextWrapper</tt>, e.g. <code>TextWrapper(Guids()) surroundWith("{", "}") toUpper</code>, which returns strings like <code>{0B9F2CC4-7A26-DF88-57BFACEB0A6152C3}</code></li>
	</ul>
	</li>
	<li><code>getBigInts(n)</code>: the values are returned as actual 128-bit ints, like <tt>135552048303739552162038533024056166383</tt></li>
</ol>


<p>The <tt>filter</tt> method is <em>not</em> supported for this generator.</p>

<h3>CreditCards</h3>
<p>This generator by default generates 16-digit credit card numbers from Visa or MasterCard, but you can instruct it otherwise through its generic apply method. The last digit is generated using Luhn's algorithm (<a href="http://en.wikipedia.org/wiki/Luhn_algorithm">http://en.wikipedia.org/wiki/Luhn_algorithm</a>, see also <a href="http://en.wikipedia.org/wiki/Credit_card_number">http://en.wikipedia.org/wiki/Credit_card_number</a>).<br>
There are 4 different "apply" methods:</p>
<ol>
	<li><code>CreditCards()</code>: 16 digit MasterCard/Visa</li>
	<li><code>CreditCards.visas</code>: 16 digit Visa numbers (starts with 4)</li>
	<li><code>CreditCards.masterCards</code>: 16 digit MasterCard numbers (starts with 51..55)</li>
	<li><code>CreditCards(prefixes: List[Long], length: Int)</code>: you decide the prefixes and length; make sure you leave room for the check digit.</li>
</ol>


<p>Additionally, you may add a call to <tt>unique()</tt>, to ensure unique values.</p>

<h3>Markov</h3>
<p>A generator for Markov chain text generation, i.e. random text based
on existing text
(see <a href="http://en.wikipedia.org/wiki/Markov_chain#Markov_text_generators">http://en.wikipedia.org/wiki/Markov_chain#Markov_text_generators</a>).
A sample...:</p>
<blockquote>
Prioriteringseffektivitet (allokeringseffektivitet) dreier seg om statsføretak, særlovsselskap og brukarorganisasjonane. Regjeringa ser annleis ut over Noreg integrert om resultata av telefon- og transport eller delvis i arbeidet med endringane og medarbeidarar som går under sektorane i oppgåvefordelinga mellom helse og resten av endringane i pakt med om å prioritere mellom den politisk-administrative styringskjeda på ulike retningar. På 90-talet dreiv Statskonsult hadde. På den forvaltningspolitikken i livet. Forvaltninga skal løysast av organisasjonsformene er i norsk forvaltningsutvikling som strekkjer seg nye former for avgjerder. Det er venta at leiarar og er under omstilling. Ein skår på kunnskap og medarbeidarar med innvandrarbakgrunn i samfunnet og dei har endra rammeverket for forvaltningsverksemder kan arbeidsdelinga mellom ansvarsområdet til å nå andre føremoner. Statstilsette må møte framtidige utfordringar både avgjerdsprosessen og 1970-talet.
</blockquote>
<p>Neither <tt>filter</tt> nor <tt>formatWith</tt> are supported.<br/>
<tt>getString</tt> returns just <i>one</i> valuable occurrence (at index 0) - the selected words concatenatenated with a space between them.</p>
<p>Both files and a string list may be used as input. A default text from <a href="http://www.regjeringen.no/nb/dep/fad/dok/regpubl/stmeld/2008-2009/stmeld-nr-19-2008-2009-">http://www.regjeringen.no/nb/dep/fad/dok/regpubl/stmeld/2008-2009/stmeld-nr-19-2008-2009-</a> is provided in the file markov.txt.</p>


<h3>Fibonaccis</h3>
<p>You cannot write a set of generators in a functional language without a Fibonacci sequence generator. Thus...<br>
This generator is written in a tail recursive manner, supported by <tt>BigInt</tt>, thus calculating Fibonacci(500)==139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125, seemingly correct.<br>
You may use <tt>filter</tt> and <tt>formatWith</tt> as for other generators.</p>

<h3>Norwegian custom generators</h3>
<p>These generators create data specific to Norwegian domains.  They use Norwegian names, as they are of limited value outside of Norway anyway.</p>

<h4>Kjennemerker</h4>
<p>No class, just an apply method without parameters.<br>
Generates strings resembling Norwegian car license plates &ndash; 2 uppercase letters (not I, M, O or Q) followed by 5 digits (use a TextWrapper to shorten them if you need).</p>

<h4>Fnr</h4>
<p>Generates legal "fodselsnummer", Norwegian "social security numbers" (<a href="http://no.wikipedia.org/wiki/F%C3%B8dselsnummer">http://no.wikipedia.org/wiki/F%C3%B8dselsnummer</a>). These are strings of 11 digits:</p>
<ol>
	<li>Birth date &ndash; "ddmmyy"</li>
	<li>A random 3-digit ID code</li>
	<li>2 check digits (using two mod11 algorithms)</li>
</ol>


<p>There are several rules pertaining to these numbers, some of which are supported by the generator.</p>
<ol>
	<li>The date part usually starts with 01-31.  However, temporary numbers called D-numbers are issued, they add 40 to the birth day (i.e. 41-71).<br>
Add a call to <code>withDnr(n)</code> to generate such numbers &ndash; n is a percentage between 0 (default, no dnrs) and 100 (all D-numbers).</li>
	<li>If you only want certain dates, use the apply method or constructor with an <code>ExtendedGenerator[DateTime]</code> argument (e.g. a <tt>Dates</tt> generator).</li>
	<li>The 3-digit ID is given in intervals signifying century.  This is not supported by the generator.</li>
	<li>The 3-digit ID is odd for men, even for women.  Call <tt>boysOnly</tt> og <tt>girlsOnly</tt> if you are a sexist.</li>
	<li>The algorithm for the check numbers leads to not all IDs being valid.  The generator ensures that all values are valid.</li>
</ol>


<p><b>Apply methods</b></p>
<ol>
	<li>Standard no-args</li>
	<li><code>Fnr(ExtendedGenerator[DateTime])</code>: (e.g. <tt>Dates</tt>) to govern which dates are produced.  See the long sample at the end of the article.</li>
</ol>


<h4>Orgnr</h4>
<p>Generates legal "organisasjonsnummer", Norwegian "organization numbers" (<a href="http://www.brreg.no/samordning/organisasjonsnummeret.html">http://www.brreg.no/samordning/organisasjonsnummeret.html</a>). These are strings of 9 digits:</p>
<ol>
	<li>The first digit is 8 or 9</li>
	<li>The last digit is a mod11 check digit</li>
</ol>


<p><b>Apply methods</b></p>
<ol>
	<li>Standard no-args</li>
</ol>


<h4>Land</h4>
<p>(Country generator.)<br>
This generator (object) reads the supplied "land.txt" file containing country names in Norwegian spelling, and uses a <tt>FromFile</tt> to supply values.</p>


<h4>Poststeder</h4>
<p>(Postal code generator.)<br>
This one is also based on a <tt>FromFile</tt> reading the supplied "postnr.txt" which contains Norwegian postal codes, formatted as "NNNN Ssss....", where NNNN is the 4-digit code, followed by a space, then the name.  There are 3 alternative invokations, they all have an optional <tt>allLines</tt> parameter (default <tt>true</tt>) for the <tt>FromFile</tt> generator:</p>
<ul>
	<li><tt>Poststeder</tt>: returns full strings as described above</li>
	<li><tt>Poststeder.postnr</tt>: returns the numeric code only</li>
	<li><tt>Poststeder.poststed</tt>: returns the name only</li>
</ul>


<p><em>Source: <a href="http://www.bring.no/hele-bring/produkter-og-tjenester/brev-og-postreklame/andre-tjenester/postnummertabeller">http://www.bring.no/hele-bring/produkter-og-tjenester/brev-og-postreklame/andre-tjenester/postnummertabeller</a></em></p>

<h4>Kommuner</h4>
<p>(County generator.)<br>
Another one based on a <tt>FromFile</tt>, reading  "kommuner.txt" which contains Norwegian county names, formatted as "NNNN Ssss....", where NNNN is a 4-digit code, followed by a space, then the name.  There are 3 alternative invokations, they all have an optional <tt>allLines</tt> parameter (default <tt>true</tt>) for the <tt>FromFile</tt> generator:</p>
<ul>
	<li><tt>Kommuner</tt>: returns full strings as described above</li>
	<li><tt>Kommuner.kommunenr</tt>: returns the numeric code only</li>
	<li><tt>Kommuner.kommunenavn</tt>: returns the name only</li>
</ul>


<p><em>Source: <a href="http://www.bring.no/hele-bring/produkter-og-tjenester/brev-og-postreklame/andre-tjenester/postnummertabeller">http://www.bring.no/hele-bring/produkter-og-tjenester/brev-og-postreklame/andre-tjenester/postnummertabeller</a></em></p>

<h4>NorskeNavn</h4>
<p>(Generator for Norwegian names.)<br>
First a bit about the background for this generator...</p>

<p>Over the years, I have "scraped" lists of names from the net &ndash; tax lists, participants in conferences and sports events etc, and tried to normalize and uniquify these lists (this bears the risk of having first and last names mixed up, and wrong capitalization...).  Then I removed first and last names that only appeared once in any combination, to avoid generating names that identifies a single person.  To these lists, I added the list from Norwegian SSB (Statistics Norway) of the most popular names, from these I have extracted the lists of names in "fornavn.txt" (a little short of 5000 first names) and "etternavn.txt" (about 8300 last names).  The lists have no notion of gender, so you might well end up with names like "Ann Abdul Hansen"...</p>

<p>To generate names</p>
<ol>
	<li>You start with the the apply method &ndash; <tt>NorskeNavn(allLines:Boolean=true)</tt> (with <tt>allLines=true</tt>, all 12500 names are read at least once)</li>
	<li>and may optionally add <tt>forOgEtternavn</tt> (default, both first and last names, creating names with 1 or 2 of each), <tt>kunFornavn</tt> (single first names only) or <tt>kunEtternavn</tt> (single last names only)</li>
	<li>the standard <tt>filter</tt> and <tt>formatWith</tt> may also be used.</li>
</ol>


<h4>RareNavn</h4>
<p>This is a simpler name generator, picking from a list of about 100 names.  These names are meant to sound "funny", read the right way, they form other words or expressions, e.g. "Buster Minal" and "Mary Christmas".. :)<br>
It supports the <tt>allLines</tt> parameter of <tt>FromFile</tt>.</p>

<h4>Adresser</h4>
<p>A generator to create strings that look like Norwegian street addresses.  It uses surnames (from <tt>NorskeNavn.kunEtternavn</tt>) and places (from <tt>Poststeder.poststed</tt>), and optionally a house number (sometimes with a letter suffix).<br>
Note that the class itself does <em>not</em> implement a generator interface, but its <code>generator(withNumbers:Boolean)</code> returns a generator (as does the apply method).</p>

<p>Apply method:</p>
<ul>
	<li><code>Adresser(withNumbers: Boolean=true)</code></li>
</ul>


<p>Samples:</p>
<pre>Vogts gate 62
Vossskroken 87C
Cowards plass 105
</pre>

<h2>Record builders</h2>
<p>Generating values is all well and fine, and you may want to use the previous generators in contexts of your own.  But often, you will want to use the test data in another context.  The generators that follow help you in building not values but data structures, and perhaps saving them to a file.</p>

<h3>Core classes</h3>
<p>There are a few base classes that the other record generators are based on. The main concept is that you create a structure by adding a list of fields (the order in which they are added is normally important) &ndash; each field has a <em>name</em> (even for the few generators that do not use it) and a value generator, typically one of the generators above.  The <tt>get</tt> methods for the record generators call the <tt>getStrings</tt> method on each field's generator, and assembles records from the combined results.</p>

<p>The main class is the <code>abstract class DataRecordGenerator[T](nulls: NullHandler)</code> whch implements <code>Generator[T]</code>.  It contains the following methods:</p>
<ul>
	<li><code>add(fieldName: String, gen:Generator[_])</code> &ndash; adds a named field (as previously mentioned, the order in which you call <tt>add</tt> becomes the order of the fields).</li>
	<li><code>add(DataField)</code>: specialized subclasses of <tt>DataField</tt> (see below) may need to be built outside the DataRecordGenerator and added "as is".</li>
	<li><code>toFile</code> / <code>appendToFile</code>: these methods, if called, must be the last call on the record generator, because they return a <tt>ToFile</tt> (which see), not the generator itself, to allow the result to be saved to a file.</li>
	<li>Subclasses may also use the protected variable <tt>fields</tt>, which is the generator list, as well as the utility method <tt>fieldNames</tt> which returns the ordered list of field names.</li>
</ul>


<p><code>StringRecordGenerator</code> is a subclass specialized for generating strings, with a notion of pre/suffixes, and an overridable <tt>newline</tt> method that defaults to the current platform line ending.</p>

<p>The <tt>NullHandler</tt> in the constructor is a sealed trait describing how <tt>null</tt> values in the input should be handled (some strategies may be less relevant for some record formats):</p>
<ol>
	<li><tt>EmptyNull</tt>: include the element as an empty string/element/..., e.g. <tt>&lt;foo/&gt;</tt> in an XML record.</li>
	<li><tt>SkipNull</tt>: exclude empty fields entirely</li>
	<li><tt>KeepNull</tt>: include null fields with an explicit "null" representation.</li>
</ol>


<p>Each field (i.e. name+ generator) is represented by a <code>case class DataField(name: String, generator: Generator[_]</code> or one of its subclasses.  In addition to its constructor arguments, it contains the overridable methods</p>
<ul>
	<li><tt>prefix</tt> / <tt>suffix</tt>: how to add "something" before or after the field value</li>
	<li><tt>transform(String)</tt>: how to transform the value from the generator's <tt>getStrings</tt> to the output string</li>
	<li><tt>getTuples(Int, NullHandler)</tt>: the method that calls the generator and produces N tuples in a <tt>(name,value)</tt> format.</li>
</ul>


<p>A couple of subclasses are provided &ndash; <tt>SingleQuoteWithEscapeDataField</tt> and <tt>DoubleQuoteWithEscapeDataField</tt>, they encapsulate their values with single/double quotes, and escapes their respective quotes with a backslash.</p>

<h3>ToCsv</h3>
<p>This generator produces values separated by a comma (or another delimiter, e.g. TAB), values are pre- and suffixed with a delimiter, by default a double quote.  By default, the first record contains field names (which can be excluded).  Access it through the apply method <tt>ToCsv</tt> with the following optional parameters</p>
<ol>
	<li><code>withHeaders: Boolean=true</code>: include header record</li>
	<li><code>delimiter:String= "\""</code>: how to enclose each value</li>
	<li><code>separator:String= ","</code>: how to separate each field</li>
</ol>


<p>The output would typically look like this:</p>
<pre>"id","userId","ssn","mail","active"
"1","SSQH","23040852859","oviydeo@nvyebr.org","false"
"2","RYZJ","14088638868","pwrdsi@rvyhjvimz.gov","false"
"3","UODG","08039917611","uex.hshuka@anqfj.net","false"
</pre>

<h3>ToFixedWidth</h3>
<p>This generator produces data in fixed width fields, where each value is padded with blanks (or truncated) to a fixed width.  The inherited <tt>add</tt> method cannot be used, use <code>add(fieldName: String, gen: Generator[_], width: Int)</code> to add fields. The apply method is <code>ToFixedWidth(withHeaders: Boolean=true)</code> (as the output of a header record is optional).</p>

<p>Sample output:</p>
<pre>rec u  ssn
HEADEFB17046606698
VALUNE 01027711576
</pre>

<p><tt>skipNull</tt> is not supported for this generator.</p>

<h3>XML</h3>
<p>There are two different XML generators, and a generator for HTML. As opposed to other record generators, these differentiate between the <tt>get</tt> and <tt>getStrings</tt> methods, the latter pretty-prints the result to create a more readable layout.</p>

<h4>ToXmlElements</h4>
<p>The output from this generator is a set of data records, optionally enclosed in a root record. The apply method <tt>ToXmlElements()</tt> has 3 named parameters:</p>
<ol>
	<li><tt>rootName:String</tt>: if this parameter has a value, a root record with that name is generated, enclosing the other records.</li>
	<li><tt>recordName:String</tt>: must be given, sets he name of the base element for each record</li>
	<li><tt>nullHandler</tt>: see above, default <tt>EmptyNull</tt></li>
</ol>


<p>The introductory example shows sample output from this.</p>

<h4>ToXmlAttribute</h4>
<p>Much like the previous, but the fields are represented as <em>attributes</em> on the (empty) data record, rather than enclosed elements.  Parameters are like the previous.</p>

<p>Sample without root record and with empty nulls:</p>
<pre>
&lt;data homePage="" userId="RKGG" id="1" name="Gleihoy Tmfsmr" born=""&gt;&lt;/data&gt;
&lt;data homePage="http://eeofau.net" userId="EALP" id="2" name="Jnnadfpnfbjjv Jsokovknmvn" born="2004-03-14"&gt;&lt;/data&gt;
&lt;data homePage="https://jdje.net" userId="GBDB" id="3" name="Gmbgbsnmatmiij Kafkdyydkkfkoi" born="1982-06-26"&gt;&lt;/data&gt;
</pre>

<h4>ToHtml</h4>
<p>This one formats its output as an HTML table, optionally as a complete HTML document.  The apply methods has two optional parameters:</p>
<ol>
	<li><tt>pageTitle:String</tt>: if this parameter has a value, a complete HTML document with that title and heading is generated, enclosing the table.</li>
	<li><tt>nullHandler</tt>: see above, default <tt>EmptyNull</tt>.  <tt>EmptyNull</tt> is handled with a <code>&lt;td&gt;&amp;nbsp;&lt;/td&gt;</code> cell, <tt>SkipNull</tt> should not be used.</li>
</ol>


<p>Sample output:</p>
<pre>
&lt;html&gt;
   &lt;head&gt;
      &lt;title&gt;Brukere&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;h1&gt;Brukere&lt;/h1&gt;
      &lt;table border="border"&gt;
         &lt;tr&gt;
            &lt;th&gt;id&lt;/th&gt;
            &lt;th&gt;userId&lt;/th&gt;
            &lt;th&gt;ssn&lt;/th&gt;
            &lt;th&gt;born&lt;/th&gt;
            &lt;th&gt;name&lt;/th&gt;
            &lt;th&gt;homePage&lt;/th&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;XNAO&lt;/td&gt;
            &lt;td&gt;05068636754&lt;/td&gt;
            &lt;td&gt;1986-06-05&lt;/td&gt;
            &lt;td&gt;Anna George Lund&lt;/td&gt;
            &lt;td&gt;&nbsp;&lt;/td&gt;
         &lt;/tr&gt;
      &lt;/table&gt;
   &lt;/body&gt;
&lt;/html&gt;</pre>

<h3>ToWiki</h3>
<p>Another way to output a table is to use the wiki generator.  No moving parts here, it simply generates markup syntax like this:</p>
<pre>|| id || userId || ssn || mail || active ||
| 1 | ZYFR | 27020785859 | ueaqefjn@iojuwy.no | X |
| 2 | AIUS | 16021276441 | lgdnjli.luccdz@uogugujjq.gov | |
| 3 | WRCB | 05086007810 | | X |
</pre>

<h3>ToJson</h3>
<p>No prize for guessing the output format from this generator...<br>
There are two different add methods, the familiar <tt>add</tt> method, and a similar <tt>addQuoted</tt>, the latter should be used for any values that need double-quoted output (almost anything but ints, booleans and nested JSON; nulls are not quoted).<br>
The apply method has 3 parameters:</p>
<ol>
	<li><tt>header:String</tt>: This is the label for each record (ignored if <tt>bare</tt>, see below)</li>
	<li><tt>bare:Boolean=false</tt>: This is intended for nesting
	JSON-generators.  If you want to generate embedded records,
	use <tt>bare=true</tt> for the inner generators, e.g.:
<pre>val addressGen= ToJson(bare=true).addQuoted("line1", ....)...
val customerGen= ToJson(header="customer").add("address", addressGen) ...
// => "customer": { "address": { "line1": ... }, ...}</pre>
</li>
	<li><code>nulls: NullHandler= KeepNull</code>: as described above</li>
</ol>



<h3>ToSql</h3>
<p>Often, you will need to put test data into a data base.  This
generator tries to help you...  It generates records of the form <code>insert into tableName (field1, field2,...) values (value1, value2, ...);</code>.</p>

<p>To facilitate quoting, you must call the alternative add method for values that need quotes &ndash; they are then single quoted (and embedded single quotes escaped):</p>
<ul>
	<li><code>addQuoted(fieldName: String, gen: Generator[_])</code></li>
</ul>


<p>The apply method needs to know the table name, you may optionally use a record separator different from ";":</p>
<ul>
	<li><code>ToSql(tableName: String, exec: String=";")</code></li>
</ul>


<p>Sample output:</p>
<pre>insert into User (id, userId, born, name, mail)
values (1, 'UGRY', 1951-11-25, 'Vgdfhpgyp Fvtniivskmjkeaaol', 'udkad@efrghssgn.gov');
insert into User (id, userId, born, name, mail)
values (2, 'HWTG', null, 'Tykpieydmkdnsir Lioesngyhfrvatbsbe', 'idboyjq@cakcrrrny.no');
insert into User (id, userId, born, name, mail)
values (3, 'RBWC', 1951-08-15, 'Kmdiklyumethyf Paabya', null);</pre>

<h3>ToFile</h3>
<p>This generator is typically the end of a chain, and called implicitly
by either <tt>toFile</tt> or <tt>appendToFile</tt> from a record
generator, but may also be called through the apply method</p>
<pre>apply[T](fileName:String,
         generator: Generator[T],
         append:Boolean=false,
         charSet:String="ISO-8859-1")</pre>
<p>When <tt>get</tt> (or <tt>getStrings</tt>) is called, values are obtained from the embedded generator, and written/appended to the named file.</p>

<h2>Miscellaneous</h2>

<h3>Printer</h3>
<p>All the test suites uses the <tt>Printer</tt> trait.  This contains a single method: <code>def print(localPrint:Boolean)(printFun: =&gt;Unit )</code>.  If either the <tt>localPrint</tt> argument or the local <tt>centralPrint</tt> val is true, the <tt>printFun</tt> method is executed.  I use it to visually inspect the results, create samples etc.</p>

<h3>Percentage</h3>
<p>This little trait provides a <tt>hit(percent:Int)</tt> method that randomly returns <tt>true</tt> in about <tt>percent</tt> % of its calls (the argument should be an int in the range 0..100).  Used by <tt>SomeNulls</tt> and <tt>Fnr</tt>.</p>

<h2>Extended example</h2>

<p>For this last sample, we'll look at generation of data for several SQL tables.  The data structure to fill looks like this:</p>

<ul>
	<li>Address:
	<ul>
		<li>Street</li>
		<li>Postal code (Norwegian: name &amp; number)</li>
	</ul>
	</li>
	<li>Customer
	<ul>
		<li>ID</li>
		<li>SSN (Norwegian: fodselsnummer) (optional)</li>
		<li>Date of birth</li>
		<li>Name (Norwegian)</li>
		<li>Address (embedded)</li>
	</ul>
	</li>
	<li>Product
	<ul>
		<li>ID</li>
		<li>Name</li>
	</ul>
	</li>
	<li>Order
	<ul>
		<li>ID</li>
		<li>State (one of 'Pending', 'Ready', 'Delivered, 'Closed')</li>
		<li>Customer (by ID)</li>
		<li>Order date (optional)</li>
		<li>Set of Order lines</li>
	</ul>
	</li>
	<li>Order line
	<ul>
		<li>Order (by ID)</li>
		<li>Line no. (sequential)</li>
		<li>Product (by ID)</li>
		<li>Info (optional, string)</li>
	</ul>
	</li>
</ul>

<pre>
package no.mesan.testdatagen.generators.sample

import no.mesan.testdatagen.aggreg.{FieldConcatenator, SomeNulls, TextWrapper, WeightedGenerator}
import no.mesan.testdatagen.generators.{Dates, Doubles, Fixed, FromList, Ints}
import no.mesan.testdatagen.generators.misc.Names
import no.mesan.testdatagen.generators.norway.{Adresser, Fnr, Poststeder}
import no.mesan.testdatagen.recordgen.ToSql

object LongerSample extends App {
  // These are the total of numbers we will generate for the different categories
  val totalOrders= 200
  val totalProducts= totalOrders/2
  val totalCustomers= totalOrders/3
  val totalOrderLines= totalOrders*3

  // We generate one script for all data
  val resultFile= "orders.sql"

  // To be able to reuse values between records, we generate some values in advance,
  // specifically IDs (for foreign keys) and dates (for correlation between birth dates
  // and "fodselsnummer")
  val customerIds= FromList(Ints().from(1).to(10000).unique.get(totalCustomers))
  val birthDates= Dates() from (y=1921) to (y=1996) get(totalCustomers)
  val productIds= FromList(Ints().from(1).to(100000).unique.get(totalProducts))
  val orderIds= FromList(Ints().from(1).to(1000).unique.get(totalOrders)) sequential
  val postSteder= FromList(Poststeder() get(totalCustomers)) sequential

  // Populating the customer table - no dependencies
  val customerGenerator=
    ToSql("customer")
    .add("id", customerIds)
    .addQuoted("fnr", SomeNulls(25, Fnr(FromList(birthDates) sequential)))
    .addQuoted("born", FromList(birthDates) formatWith(Dates.dateFormatter("yyyy-MM-dd")) sequential)
    .addQuoted("adr", Adresser())
    .addQuoted("postnr", TextWrapper(postSteder).substring(0, 4))
    .addQuoted("poststed", TextWrapper(postSteder).substring(5))

  // and products - no dependencies either
  val productGenerator=
    ToSql("product")
    .add("id", productIds)
    .addQuoted("name", WeightedGenerator()
                         .add(60, Names(1))
                         .add(40, Names(2)))

  // Orders are connected to customers through customerIds
  val orderGenerator=
    ToSql("order")
    .add("id", orderIds)
    .addQuoted("status", FromList("Pending", "Ready", "Delivered", "Closed"))
    .add("customer", customerIds)
    .addQuoted("orderDate", Dates() from(y=2010) to(y=2013) format("yyyy-MM-dd"))

  // And order_lines connected to orders and products
  val orderLineGenerator=
    ToSql("order_line")
    .add("order", orderIds)
    .add("product", productIds)
    .add("lineNo", Ints() from(1) sequential)
    .addQuoted("info",
        SomeNulls(60,
            WeightedGenerator()
              .add(10, Fixed("Restock"))
              .add(5, Fixed("Check!"))
              .add(20,  TextWrapper(FieldConcatenator()
                        .add(Fixed("Amount: "))
                        .add(Doubles() from (1) to (300) format("%5.2f"))
                        .add(FromList(" l", " kg", "", " m")))
                        .trim)))

  // The generators are all set -- create result
  customerGenerator toFile(resultFile) get(totalCustomers)
  productGenerator appendToFile(resultFile) get(totalProducts)
  orderGenerator appendToFile(resultFile) get(totalOrders)
  orderLineGenerator appendToFile(resultFile) get(totalOrderLines)
}</pre>

<p>The output looks like this (excerpt):</p>
<pre>insert into customer (id, fnr, born, adr, postnr, poststed)
values (9399, '11109252079', '1992-10-11', 'Kuvens plass 81', '8733', 'Stuvland');
insert into customer (id, fnr, born, adr, postnr, poststed)
values (6370, null, '1990-06-16', 'Oddassvingen 119', '0903', 'Oslo');
insert into customer (id, fnr, born, adr, postnr, poststed)
values (4674, '15028313397', '1983-02-15', 'Spords plass 77', '4838', 'Arendal');
insert into customer (id, fnr, born, adr, postnr, poststed)
values (2542, '06117470669', '1974-11-06', 'Oldens plass 12', '0604', 'Oslo');
...
insert into product (id, name) values (78471, 'Jhtb Iktaeyaihjrluso');
insert into product (id, name) values (91325, 'Zsughfsy Bmpkfag');
insert into product (id, name) values (76771, 'Uopal');
insert into product (id, name) values (39087, 'Gbdnypsynojehsj');
insert into product (id, name) values (24766, 'Kmjh Smyo');
insert into product (id, name) values (93930, 'Kvjtdasoshbgonsvpl Otu');
insert into product (id, name) values (60291, 'Ubhemiague');
...
insert into order (id, status, customer, orderDate)
values (673, 'Closed', 5327, '2011-08-10');
insert into order (id, status, customer, orderDate)
values (225, 'Ready', 318, '2012-05-30');
insert into order (id, status, customer, orderDate)
values (918, 'Pending', 2871, '2012-07-20');
insert into order (id, status, customer, orderDate)
values (734, 'Pending', 5468, '2010-03-31');
insert into order (id, status, customer, orderDate)
values (769, 'Closed', 3827, '2011-09-05');
...
insert into order_line (order, product, lineNo, info)
values (483, 49561, 11, 'Amount: 296,06');
insert into order_line (order, product, lineNo, info)
values (408, 24766, 12, null);
insert into order_line (order, product, lineNo, info)
values (297, 47355, 107, 'Restock');
insert into order_line (order, product, lineNo, info)
values (898, 18387, 14, null);
insert into order_line (order, product, lineNo, info)
values (703, 99956, 15, null);
insert into order_line (order, product, lineNo, info)
values (227, 33004, 16, null);
insert into order_line (order, product, lineNo, info)
values (319, 32357, 17, null);
...
</pre>

<h2>Notes</h2>

<h3>TODO</h3>
<ol>
	<li>Could perhaps use <tt>Stream</tt> for get(Strings)? Or maybe not...</li>
	<li>FromFile &ndash; type checking does not work</li>
	<li>Xml &ndash; nesting not available</li>
	<li>Analyzing SQL DDL and/or domain classes to generate a skeleton for test data generators</li>
</ol></body>
</html>
